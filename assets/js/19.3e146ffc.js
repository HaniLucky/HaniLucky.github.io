(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{221:function(a,t,s){"use strict";s.r(t);var e=s(0),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"常见面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题"}},[a._v("#")]),a._v(" 常见面试题")]),a._v(" "),s("h2",{attrs:{id:"分布式如何保证数据一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式如何保证数据一致性"}},[a._v("#")]),a._v(" 分布式如何保证数据一致性")]),a._v(" "),s("h2",{attrs:{id:"分布式锁的实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的实现方式"}},[a._v("#")]),a._v(" 分布式锁的实现方式")]),a._v(" "),s("h3",{attrs:{id:"为什么要使用分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用分布式锁"}},[a._v("#")]),a._v(" 为什么要使用分布式锁")]),a._v(" "),s("p",[a._v("需要对某条数据进行多线程同步访问的时候")]),a._v(" "),s("h3",{attrs:{id:"实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[a._v("#")]),a._v(" 实现方式")]),a._v(" "),s("ul",[s("li",[a._v("redis")]),a._v(" "),s("li",[a._v("Zookeerper")]),a._v(" "),s("li",[a._v("数据库version或者时间戳"),s("br"),a._v(" "),s("a",{attrs:{href:"https://blog.csdn.net/wuzhiwei549/article/details/80692278",target:"_blank",rel:"noopener noreferrer"}},[a._v("分布式锁的实现"),s("OutboundLink")],1),s("br"),a._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/linjiqin/p/8003838.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("redis锁的正确实现方式"),s("OutboundLink")],1)])]),a._v(" "),s("h2",{attrs:{id:"多线程的创建方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程的创建方式"}},[a._v("#")]),a._v(" 多线程的创建方式")]),a._v(" "),s("ol",[s("li",[a._v("继承Thread类")]),a._v(" "),s("li",[a._v("实现Runable接口")]),a._v(" "),s("li",[a._v("使用Canable创建")]),a._v(" "),s("li",[a._v("使用线程池")])]),a._v(" "),s("blockquote",[s("p",[a._v("常用的线程池"),s("br"),a._v("\nnewCachedThreadPool"),s("br"),a._v("\nnewFixedThreadPool"),s("br"),a._v("\nnewSingleThreadExecutor"),s("br"),a._v("\nnewScheduleThreadPool")])]),a._v(" "),s("h2",{attrs:{id:"线程池如何设置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程池如何设置"}},[a._v("#")]),a._v(" 线程池如何设置")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 线程池 线程MAX数量 推荐使用cpu数量*2")]),a._v("\n "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// CPU密集型任务 一般配置线程数=CPU总核心数+1    (+1是为了利用等待空闲)")]),a._v("\n "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// IO密集型任务  一般配置线程数=CPU总核心数 * 2 +1")]),a._v("\n "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("err"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runtime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getRuntime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("availableProcessors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("h2",{attrs:{id:"wait-和sleep-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#wait-和sleep-的区别"}},[a._v("#")]),a._v(" wait()和sleep()的区别")]),a._v(" "),s("ul",[s("li",[a._v("共同点:\n他们都是在多线程环境下,都可以在调用处指定阻塞指定的毫秒值.")]),a._v(" "),s("li",[a._v("不同点:")])]),a._v(" "),s("ol",[s("li",[a._v("wait()睡眠时,释放对象锁;sleep()睡眠时,保持对象锁,仍然占有该锁")]),a._v(" "),s("li",[a._v("wait是Object的方法,sleep是Thread类的方法")]),a._v(" "),s("li",[a._v("wait,notify,notityAll只能在同步控制方法和同步控制块中使用,而sleep可以在任何地方")]),a._v(" "),s("li",[a._v("sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断")])]),a._v(" "),s("h2",{attrs:{id:"集合的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合的分类"}},[a._v("#")]),a._v(" 集合的分类")]),a._v(" "),s("h3",{attrs:{id:"list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),s("blockquote",[s("p",[a._v("List 有序(元素存入集合和取出的顺序一致,元素有索引,元素可以重复)")])]),a._v(" "),s("ol",[s("li",[a._v("ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素")]),a._v(" "),s("li",[a._v("LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素")]),a._v(" "),s("li",[a._v("Vector:底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素")])]),a._v(" "),s("h3",{attrs:{id:"set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),s("blockquote",[s("p",[a._v("无序(元素存入集合和取出的顺序不一致,不可以存储重复的元素.必须保证元素唯一性)")])]),a._v(" "),s("ol",[s("li",[a._v("HashSet:底层是hash表 线程不同步 无序 高效")]),a._v(" "),s("li",[a._v("LinkHashSet: 有序 hashSet的子类")]),a._v(" "),s("li",[a._v("TreeSet:对Set集合中的元素进行指定的顺序排序.不同步.TreeSet底层是二叉树")])]),a._v(" "),s("h3",{attrs:{id:"map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),s("ol",[s("li",[a._v("HashMap:底层是hash表结构,线程是不同步的,可以存储null键null值.")]),a._v(" "),s("li",[a._v("HashTable:底层是hash表接口,线程是同步的.不可以存储null键null值.")]),a._v(" "),s("li",[a._v("TreeMap:底层是二叉树结构,可以对map中指定的键进行排序.")])]),a._v(" "),s("h2",{attrs:{id:"arraylist扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist扩容机制"}},[a._v("#")]),a._v(" ArrayList扩容机制")]),a._v(" "),s("p",[a._v("初始长度10,扩容每次是上次的1.5倍")]),a._v(" "),s("h2",{attrs:{id:"hashmap和hashtable的初始化和扩容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap和hashtable的初始化和扩容"}},[a._v("#")]),a._v(" HashMap和HashTable的初始化和扩容")]),a._v(" "),s("ul",[s("li",[a._v("HashMap 的初始长度是16,扩容是2倍")]),a._v(" "),s("li",[a._v("HashTable 初始长度是11,扩容是2n+1")])]),a._v(" "),s("h2",{attrs:{id:"hahsmap和hashtable的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hahsmap和hashtable的区别"}},[a._v("#")]),a._v(" HahsMap和HashTable的区别")]),a._v(" "),s("ol",[s("li",[a._v("HahsMap是线程不安全,效率高.HashTable是线程安全的,效率低")]),a._v(" "),s("li",[a._v("HahsMap支持null键null值,HashTable不支持null键null值")]),a._v(" "),s("li",[a._v("HashMap的初始长度是16,扩容是2倍;HashTable初始长度是11,扩容是2n+1")])]),a._v(" "),s("h4",{attrs:{id:"hashmap-put一个元素的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-put一个元素的过程"}},[a._v("#")]),a._v(" HashMap put一个元素的过程")]),a._v(" "),s("blockquote",[s("p",[a._v("todo")])]),a._v(" "),s("h4",{attrs:{id:"如果我想使用hashmap还要线程安全怎么处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果我想使用hashmap还要线程安全怎么处理"}},[a._v("#")]),a._v(" 如果我想使用hashMap还要线程安全怎么处理")]),a._v(" "),s("ol",[s("li",[a._v("concurrent并发包下的ConcurrentHashMap。  效率和hashTable差不多 对象锁,每次都去获取这个对象锁")]),a._v(" "),s("li",[a._v("Collections.synchronizedMap(new Hashtable<String,Object>());   分段锁 cas+synchronized+volatile来实现\n使用的技术栈")])]),a._v(" "),s("h2",{attrs:{id:"springboot有哪些配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springboot有哪些配置"}},[a._v("#")]),a._v(" springboot有哪些配置")]),a._v(" "),s("h2",{attrs:{id:"ajax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ajax"}},[a._v("#")]),a._v(" ajax")]),a._v(" "),s("h2",{attrs:{id:"ngixn如何应对高并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ngixn如何应对高并发"}},[a._v("#")]),a._v(" ngixn如何应对高并发")]),a._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://blog.csdn.net/hjh15827475896/article/details/53442800",target:"_blank",rel:"noopener noreferrer"}},[a._v("单机 nginx 应对高并发处理"),s("OutboundLink")],1),a._v("\n加机器")])]),a._v(" "),s("h4",{attrs:{id:"ngixn的分发机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ngixn的分发机制"}},[a._v("#")]),a._v(" ngixn的分发机制")]),a._v(" "),s("p",[a._v("1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n2、weight\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n3、ip_hash\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n4、fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n5、url_hash（第三方）\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。")]),a._v(" "),s("h2",{attrs:{id:"springmvc一个请求的执行过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc一个请求的执行过程"}},[a._v("#")]),a._v(" springmvc一个请求的执行过程")]),a._v(" "),s("h2",{attrs:{id:"mq的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq的使用场景"}},[a._v("#")]),a._v(" MQ的使用场景")]),a._v(" "),s("ol",[s("li",[a._v("发短信")]),a._v(" "),s("li",[a._v("发邮件")]),a._v(" "),s("li",[a._v("日志收集")])]),a._v(" "),s("h2",{attrs:{id:"mq消费方失败如何保证数据一致"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq消费方失败如何保证数据一致"}},[a._v("#")]),a._v(" MQ消费方失败如何保证数据一致")]),a._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://www.jianshu.com/p/eb571e4065ec",target:"_blank",rel:"noopener noreferrer"}},[a._v("MQ消息最终一致性解决方案"),s("OutboundLink")],1)])]),a._v(" "),s("p",[a._v("todo 消费方持久化,由生产者手动执行")]),a._v(" "),s("h2",{attrs:{id:"简诉浏览器一个url请求是一个怎样的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简诉浏览器一个url请求是一个怎样的过程"}},[a._v("#")]),a._v(" 简诉浏览器一个url请求是一个怎样的过程")]),a._v(" "),s("h2",{attrs:{id:"redis的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的数据结构"}},[a._v("#")]),a._v(" Redis的数据结构")]),a._v(" "),s("p",[a._v("String、Hash、List、Set、ZSet(有序set)")]),a._v(" "),s("h2",{attrs:{id:"redis的持久化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的持久化方式"}},[a._v("#")]),a._v(" Redis的持久化方式")]),a._v(" "),s("blockquote",[s("p",[a._v("RDB\nAOF")])]),a._v(" "),s("h3",{attrs:{id:"rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[a._v("#")]),a._v(" RDB")]),a._v(" "),s("p",[a._v("在指定时间内将内存中的数据集快照写入到磁盘")]),a._v(" "),s("ul",[s("li",[a._v("优点:")])]),a._v(" "),s("ol",[s("li",[a._v("只有一份rdb文件,可随时备份")]),a._v(" "),s("li",[a._v("比AOF文件小,加载效率高.")]),a._v(" "),s("li",[a._v("不阻塞主进程,io效率高")])]),a._v(" "),s("h3",{attrs:{id:"aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[a._v("#")]),a._v(" AOF")]),a._v(" "),s("pre",[s("code",[a._v("将每一个操作以日志的形式记录在服务器,在redis启动之初读取文件来重新构建数据库,保证启动后数据库中的数据是完整的\n")])]),a._v(" "),s("ul",[s("li",[a._v("优点:\n每次改动同步数据安全性好\n以append的方式追加日志,不会对旧日志文件产生影响")])]),a._v(" "),s("h2",{attrs:{id:"redis使用过程中会遇到的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis使用过程中会遇到的问题"}},[a._v("#")]),a._v(" Redis使用过程中会遇到的问题")]),a._v(" "),s("blockquote",[s("p",[a._v("缓存穿透\n缓存雪崩\n缓存击穿")])]),a._v(" "),s("h3",{attrs:{id:"一句话总结问题及方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一句话总结问题及方案"}},[a._v("#")]),a._v(" 一句话总结问题及方案")]),a._v(" "),s("h4",{attrs:{id:"缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),s("p",[a._v("问题:是指查询一个数据库一定不存在的数据.")]),a._v(" "),s("p",[a._v("方案:如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒")]),a._v(" "),s("h4",{attrs:{id:"缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),s("p",[a._v("问题:是指在某一个时间段，缓存集中过期失效。")]),a._v(" "),s("p",[a._v("方案:在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间。热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。")]),a._v(" "),s("h4",{attrs:{id:"缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[a._v("#")]),a._v(" 缓存击穿")]),a._v(" "),s("p",[a._v("问题:是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。")]),a._v(" "),s("p",[a._v("方案:让缓存永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了")]),a._v(" "),s("p",[a._v("OTM\n[toc]")]),a._v(" "),s("h2",{attrs:{id:"数据库设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[a._v("#")]),a._v(" 数据库设计")]),a._v(" "),s("ol",[s("li",[a._v("三大范式")])]),a._v(" "),s("ul",[s("li",[a._v("第一范式:表中的所有字段都是不可分解的原子值")]),a._v(" "),s("li",[a._v("第二范式:在第一范式的基础上,每一列都和主键相关")]),a._v(" "),s("li",[a._v("第三范式:确保每一列和主键是直接相关而不是间接相关")])]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("反范式")])]),a._v(" "),s("ul",[s("li",[a._v("反范式化:反范式化指的是通过增加冗余或重复的数据来提高数据库的性能(例如 user_code和user_name)")])]),a._v(" "),s("blockquote",[s("p",[a._v("反范式化可以减少关联查询时join表的次数")])]),a._v(" "),s("h2",{attrs:{id:"索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[a._v("#")]),a._v(" 索引")]),a._v(" "),s("h3",{attrs:{id:"索引的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引的分类"}},[a._v("#")]),a._v(" 索引的分类")]),a._v(" "),s("blockquote",[s("p",[a._v("普通索引、唯一索引、主键索引、联合索引、全文索引")])]),a._v(" "),s("ul",[s("li",[a._v("普通索引：最基本的索引，没有任何限制")]),a._v(" "),s("li",[a._v('唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。')]),a._v(" "),s("li",[a._v("主键索引：它 是一种特殊的唯一索引，不允许有空值。")]),a._v(" "),s("li",[a._v("全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。")]),a._v(" "),s("li",[a._v("组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。")])]),a._v(" "),s("h3",{attrs:{id:"索引的结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引的结构"}},[a._v("#")]),a._v(" 索引的结构")]),a._v(" "),s("p",[a._v("b+tree索引、hash索引\nb+tree是使用最频繁的索引数据结构,b+tree的速度比不上hash,但b+tree很适合做排序操作")]),a._v(" "),s("h3",{attrs:{id:"创建索引的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建索引的方式"}},[a._v("#")]),a._v(" 创建索引的方式")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("   普通索引\n        ALTER TABLE `table_name` ADD INDEX index_name ( `column` )\n    唯一索引\n        ALTER TABLE `table_name` ADD UNIQUE ( `column` )\n    主键索引\n        ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )\n    全文索引\n        ALTER TABLE `table_name` ADD FULLTEXT ( `column`)\n    多列索引\n        ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("h3",{attrs:{id:"索引的优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引的优缺点"}},[a._v("#")]),a._v(" 索引的优缺点")]),a._v(" "),s("ul",[s("li",[a._v("优点")])]),a._v(" "),s("ol",[s("li",[a._v("通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。")]),a._v(" "),s("li",[a._v("可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。")]),a._v(" "),s("li",[a._v("可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。")]),a._v(" "),s("li",[a._v("在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。")]),a._v(" "),s("li",[a._v("通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。")])]),a._v(" "),s("ul",[s("li",[a._v("缺点")])]),a._v(" "),s("ol",[s("li",[a._v("创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。")]),a._v(" "),s("li",[a._v("索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。")]),a._v(" "),s("li",[a._v("当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。")])]),a._v(" "),s("h3",{attrs:{id:"什么样的字段适合创建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么样的字段适合创建索引"}},[a._v("#")]),a._v(" 什么样的字段适合创建索引")]),a._v(" "),s("p",[a._v("一般来说，应该在这些列上创建索引，例如：在经常需要搜索的列上，可以加快搜索的速度；")]),a._v(" "),s("ol",[s("li",[a._v("在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；")]),a._v(" "),s("li",[a._v("在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；")]),a._v(" "),s("li",[a._v("在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；")]),a._v(" "),s("li",[a._v("在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；")]),a._v(" "),s("li",[a._v("在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。")])]),a._v(" "),s("h3",{attrs:{id:"什么情况创建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么情况创建索引"}},[a._v("#")]),a._v(" 什么情况创建索引")]),a._v(" "),s("p",[a._v("建立索引，一般按照select的where条件来建立，比如： select的条件是where f1 and f2，那么如果我们在字段f1或字段f2上简历索引是没有用的，只有在字段f1和f2上同时建立索引才有用等。\n"),s("strong",[a._v("什么样的字段不适合创建索引:")]),a._v("\n同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：")]),a._v(" "),s("ol",[s("li",[a._v("对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。")]),a._v(" "),s("li",[a._v("对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。")]),a._v(" "),s("li",[a._v("对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。")]),a._v(" "),s("li",[a._v("当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。")])]),a._v(" "),s("h2",{attrs:{id:"事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),s("h3",{attrs:{id:"事务的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的特性"}},[a._v("#")]),a._v(" 事务的特性")]),a._v(" "),s("p",[a._v("ACID 原子性 一致性 隔离性 持久性")]),a._v(" "),s("ul",[s("li",[a._v("原子性:事务不可分割,要么全部完成,要么全部不完成.如果在事务过程中出现错误,则全部回滚.")]),a._v(" "),s("li",[a._v("一致性:事务结束前和结束后,数据库的完整性约束没有被破环.比如A向B转账,不能A扣了钱,B没有却没有收到.")]),a._v(" "),s("li",[a._v("隔离性:同一时间,只允许一个事务请求同一数据,不同事务之间彼此没有任何干扰,比如A正在从一张银行卡中取钱,在A取钱结束之前,B不能向这张卡转账")]),a._v(" "),s("li",[a._v("持久性:事务完成之后,事务对数据库的所有更新将被保存到数据库,不能回滚。")])]),a._v(" "),s("h3",{attrs:{id:"事务的隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离级别"}},[a._v("#")]),a._v(" 事务的隔离级别")]),a._v(" "),s("blockquote",[s("p",[a._v("读未提交、读已提交、可重复读、串行化")])]),a._v(" "),s("ul",[s("li",[a._v("读未提交什么都不能防止")]),a._v(" "),s("li",[a._v("读已经提交可以有效防止脏读  orcal ,sql server")]),a._v(" "),s("li",[a._v("可重复读可防止不可重复读,脏读  mysql默认的事务隔离级别")]),a._v(" "),s("li",[a._v("串行化可防止脏读,不可重复读,幻读")])]),a._v(" "),s("h3",{attrs:{id:"事务并发引发的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务并发引发的问题"}},[a._v("#")]),a._v(" 事务并发引发的问题")]),a._v(" "),s("ul",[s("li",[a._v("脏读:一个事务读取了一个事务未提交的数据")]),a._v(" "),s("li",[a._v("不可重复读:一个事务读取表中的某一行数据,多次读取结果不同")])]),a._v(" "),s("p",[a._v("脏读和不可重复读的区别是:脏读是读取了前一事务还未提交的数据,不可重复读是重新读取了前一事务提交的数据")]),a._v(" "),s("ul",[s("li",[a._v("幻读:一个事务读取到了别的事务插入的数据,导致前后查询不一致")])]),a._v(" "),s("p",[a._v("不可重复读和幻读的区别是:不可重复读侧重的修改,幻读侧重的是新增和删除.解决不可重复读的方法是锁住满足条件的行,解决幻读的方案是锁表")]),a._v(" "),s("blockquote",[s("p",[a._v("补充:")])]),a._v(" "),s("ol",[s("li",[a._v("串行化效率很低,读写数据都会锁住整张表")]),a._v(" "),s("li",[a._v("隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为读已提交，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。")])]),a._v(" "),s("h2",{attrs:{id:"数据库优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库优化"}},[a._v("#")]),a._v(" 数据库优化")]),a._v(" "),s("h3",{attrs:{id:"为什么要优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要优化"}},[a._v("#")]),a._v(" 为什么要优化")]),a._v(" "),s("ul",[s("li",[a._v("要优化的原因,查询慢")]),a._v(" "),s("li",[a._v("查询慢的原因,进行了全表扫描")])]),a._v(" "),s("h3",{attrs:{id:"可优化的点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可优化的点"}},[a._v("#")]),a._v(" 可优化的点")]),a._v(" "),s("ul",[s("li",[a._v("合理的搜索引擎")]),a._v(" "),s("li",[a._v("表结构设计合理(范式和反范式)")]),a._v(" "),s("li",[a._v("查询的优化")]),a._v(" "),s("li",[a._v("架构级别的优化")])]),a._v(" "),s("ol",[s("li",[a._v("合理的搜索引擎")])]),a._v(" "),s("ul",[s("li",[a._v("MYISAM(不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表)")]),a._v(" "),s("li",[a._v("Memory")]),a._v(" "),s("li",[a._v("InnoDB(5.5默认)(InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引)")]),a._v(" "),s("li",[a._v("Archive\n"),s("a",{attrs:{href:"https://blog.csdn.net/zhangyuan19880606/article/details/51217952",target:"_blank",rel:"noopener noreferrer"}},[a._v("4种mysql引擎"),s("OutboundLink")],1)])]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("表设计优化")])]),a._v(" "),s("ul",[s("li",[a._v("索引并不是越多越好,索引固然可以提高相应的select的效率,但同时也降低了insert和update的效率.因为insert和update是可能会重建索引,所以怎样建索引需要慎重考虑,视具体的情况而定.\n"),s("em",[a._v("一个表的索引最好不要超过6个,太多的话要慎重考虑")])]),a._v(" "),s("li",[a._v("尽量使用数字型字段,若只包含数值信息的字尽量不要设计成字符型,这会降低查询和连接的效率,并增加存储开销.这是因为引擎在处理查询和连接时会逐个比较字符串中的每个字符,而对于数字型而言比较一次就行")]),a._v(" "),s("li",[a._v("对于非定长字符类型的字段,使用varchar而不是使用char\nvarchar的长度是可变的,char的长度是固定的.例如char(10)的长度是10 如果存入'abcd'长度还是10,会默认给补充空格,")]),a._v(" "),s("li",[a._v("表结构的拆分(几种常见的表拆法)\n①.核心字段一张表,非核心字段一张表\n②.大字段一张表,text和超长的vhrchar单独一张表\n③.常用字段和不常用字段的拆开")]),a._v(" "),s("li",[a._v("字段类型优先级  整型 > date,time > enum, char > varchar > blob")]),a._v(" "),s("li",[a._v("够用就行，不要慷慨(如 smallint,varcahr(N))")]),a._v(" "),s("li",[a._v("尽量避免null")])]),a._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[a._v("查询优化")])]),a._v(" "),s("blockquote",[s("p",[a._v("对查询进行优化,避免全表扫描")])]),a._v(" "),s("ul",[s("li",[a._v("在wherer和order by的列上添加索引.")]),a._v(" "),s("li",[a._v("在where条件上避免对null的判断,否则导致搜索引擎放弃使用索引而进行全表扫描 "),s("em",[a._v("赋默认值")])]),a._v(" "),s("li",[a._v("避免在where子句中使用!=或则<>操作符,否则索引失效而进行全表扫描")]),a._v(" "),s("li",[a._v("应避免在where字句中使用or来连接条件,否则索引失效而进行全表扫描\n"),s("em",[a._v("使用union all代替")])]),a._v(" "),s("li",[a._v("避免使用in和not in,否则会进行全表扫描\n"),s("em",[a._v("对于连续的值使用between")]),a._v(" "),s("em",[a._v("对于不连续的值使用 exists,not exists")])]),a._v(" "),s("li",[a._v("避免使用like")]),a._v(" "),s("li",[a._v("不要对where子句中的=号左边进行运算")]),a._v(" "),s("li",[a._v("不要对where子句中的字段进行函数处理")]),a._v(" "),s("li",[a._v("当只查询一条数据时使用LIMIT 1")])]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("系统级别的优化")])]),a._v(" "),s("ul",[s("li",[a._v("分库分表(mycat)\n分库(纵向拆分)\n分表(横向拆分)")]),a._v(" "),s("li",[a._v("加缓存(redis和ES)\n"),s("a",{attrs:{href:"https://www.php.cn/redis/425065.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("redis和es的区别"),s("OutboundLink")],1)])]),a._v(" "),s("h2",{attrs:{id:"数据库相关参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库相关参考"}},[a._v("#")]),a._v(" 数据库相关参考")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.jianshu.com/p/08d123026438",target:"_blank",rel:"noopener noreferrer"}},[a._v("三大范式"),s("OutboundLink")],1),a._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/moxiaotao/p/10120672.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("三大范式和反范式(解释的比较详细,推荐)"),s("OutboundLink")],1),a._v(" "),s("a",{attrs:{href:"https://blog.csdn.net/qq_38789941/article/details/83744271",target:"_blank",rel:"noopener noreferrer"}},[a._v("sql优化"),s("OutboundLink")],1),a._v(" "),s("a",{attrs:{href:"https://blog.csdn.net/fd2025/article/details/80339795",target:"_blank",rel:"noopener noreferrer"}},[a._v("表设计的优化(推荐)"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);